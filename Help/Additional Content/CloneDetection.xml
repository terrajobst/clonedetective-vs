<topic>
	<head>
		<title>Clone Detection</title>
		<toc index="3" />
	</head>
	<body>
		<summary>
			<p>
				This section explains what clone detection is what concepts
				you need to understand in order to effectively use it as
				a quality assessment tool.
			</p>
		</summary>
		<section title="Duplicated Source Code">
			<p>
				The goal of clone detection is to find pieces of source code
				that are duplicated somewhere else. Why is this interesting?
			</p>
			<p>
				If source code is duplicated this is often an indicator for
				quality problems because it typically has the following
				root causes:
			</p>
			<ul>
				<li>
					<b>Copy and paste coding</b>. Instead of identifying
					reusable pieces of functionality and properly factoring
					an application it is much easier and faster to just
					copy and paste an existing solution. In many cases the
					copied code is adapted to match the new requirements.
					The problem with copy and paste coding is an enormous
					increase of maintenance effort. Once you spread an
					algorithm across the application it is much harder to
					fix bugs and add new features to it because you have to
					consider all occurences in all the different flavors.
				</li>
				<li>
					<b>Architectural constraints</b>. Applications grow
					over time. A specific architecture that was perfectly
					suited when the application was initially designed
					might not be suited so well after a few releases. For
					example, consider a traditional three-tier application
					with a client-, business- and database layer. Imagine
					the application was extended so that it supports
					offline functionality for mobile devices. Since the
					business logic layer is only installed on the
					application server the clients cannot validate data
					while they are offline. However, you also want to
					check at least the most common and most important
					business rules in offline mode, because for the user
					it is much easier to fix errors when data is entered
					as opposed to doing it much later when the data is
					synchronized back to the application server. Without
					refactoring the architecture of this application the
					only way to enable offline validation of business
					rules is to copy the relevant code from the business
					layer to the client layer.
				</li>
				<li>
					<b>Programming language constraints</b>. Sometimes
					code reuse cannot be easily performed due to limitations
					of the programming language. For example, if you want
					to implement a data structure for different types in
					a type-safe way you have to duplicate a fair amount
					of source code. Since C# 2.0 you can use generics
					which overcomes most of the previous limitations.
				</li>
				<li>
					<b>Methodological constrains</b>. Common methodolgies
					such as object oriented programming easily allow code
					reuse. However, some aspects still cannot be easily
					expressed in those paradigms without duplicating
					source code. For example, cross cutting concerns such
					as logging or security must be performed in several
					methods following the same pattern and cannot be
					easily expressed in C#. On the other hand, aspect
					oriented programming can express it very well.
				</li>
			</ul>
			<p>
				Clone detection alone does not mitigate the problems
				desribed above. However, it is a tool that supports you
				in finding the pieces of code that are duplicated somewhere
				else without manually comparing each fragment against
				each other. Once you know it is duplicated you can
				review the code more intensively to decide what to do.
			</p>
		</section>
		<section title="Clones and Clone Classes">
			<p>
				Clone Detective normalizes the source code in order to
				create a fingerprint of it. During normalization certain
				characteristics of the code are eleminated such as
				whitespaces, comments, and concrete identifier names.
				This makes sure code is also found if someone has
				reformatted it or renamed an identifier. For example,
				the following two pieces of code are considered being
				identical:
			</p>
			<code xml:space="preserve">for (int i = 0; i &lt; 10; i++)
{
	Console.WriteLine("Hello World {0}", i);
}</code>			
			<code xml:space="preserve">// Print hello world ten times
for( int number=0; number&lt;10; number++ ) {
	// Print hello world with the value of
	// the number variable.
	Console.WriteLine("Hello World {0}", number);
}</code>
			<p>
				If source code is duplicated we speak of <i>clones</i>
				if we refer to the occurences. On the other hand, the
				common pattern between all occurences is called the
				<i>clone class</i>. You can think of a clone as being an
				instance of a given clone class. All clones that have
				the same clone class represent duplicates of each other.
			</p>
		</section>
	</body>
</topic>
